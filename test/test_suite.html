<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Suite - Damas Funer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(45deg, #2c3e50, #34495e);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .test-controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            text-align: center;
        }
        
        .btn {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-danger {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }
        
        .btn-warning {
            background: linear-gradient(45deg, #ffc107, #e0a800);
        }
        
        .test-results {
            padding: 20px;
        }
        
        .test-section {
            margin-bottom: 30px;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .test-section-header {
            background: #e9ecef;
            padding: 15px 20px;
            font-weight: bold;
            font-size: 1.2em;
            border-bottom: 1px solid #dee2e6;
        }
        
        .test-section-content {
            padding: 20px;
        }
        
        .test-item {
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #dee2e6;
            background: #f8f9fa;
        }
        
        .test-item.pass {
            border-left-color: #28a745;
            background: #d4edda;
        }
        
        .test-item.fail {
            border-left-color: #dc3545;
            background: #f8d7da;
        }
        
        .test-item.running {
            border-left-color: #ffc107;
            background: #fff3cd;
        }
        
        .test-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .test-status {
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        
        .test-details {
            font-size: 0.85em;
            color: #6c757d;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
        }
        
        .summary {
            background: #e9ecef;
            padding: 20px;
            border-top: 1px solid #dee2e6;
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
        }
        
        .summary.pass {
            background: #d4edda;
            color: #155724;
        }
        
        .summary.fail {
            background: #f8d7da;
            color: #721c24;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß™ Test Suite - Damas Funer</h1>
            <p>Bater√≠a de pruebas automatizadas para verificar la consistencia del c√≥digo</p>
        </div>
        
        <div class="test-controls">
            <button id="runAllTests" class="btn">üöÄ Ejecutar Todos los Tests</button>
            <button id="runGameLogicTests" class="btn">üéÆ Tests de L√≥gica de Juego</button>
            <button id="runNetworkTests" class="btn">üåê Tests de Red</button>
            <button id="downloadResults" class="btn" style="background: linear-gradient(45deg, #17a2b8, #138496);">üì• Descargar Resultados</button>
            <button id="clearResults" class="btn btn-danger">üóëÔ∏è Limpiar Resultados</button>
        </div>
        
        <div class="navigation" style="background: #e9ecef; padding: 15px; text-align: center; border-bottom: 1px solid #dee2e6;">
            <a href="test.html" class="btn" style="background: linear-gradient(45deg, #6c757d, #5a6268); color: white; border: none; padding: 10px 20px; margin: 5px; border-radius: 20px; text-decoration: none; display: inline-block;">üè† Centro de Testing</a>
            <a href="quick_tests.html" class="btn" style="background: linear-gradient(45deg, #17a2b8, #138496); color: white; border: none; padding: 10px 20px; margin: 5px; border-radius: 20px; text-decoration: none; display: inline-block;">‚ö° Tests R√°pidos</a>
            <a href="../home.html" class="btn" style="background: linear-gradient(45deg, #dc3545, #c82333); color: white; border: none; padding: 10px 20px; margin: 5px; border-radius: 20px; text-decoration: none; display: inline-block;">üè† Volver al Inicio</a>
        </div>
        
        <div class="test-results" id="testResults">
            <div class="test-section">
                <div class="test-section-header">üìä Resumen de Tests</div>
                <div class="test-section-content">
                    <div id="testSummary" class="summary">
                        Presiona "Ejecutar Todos los Tests" para comenzar
                    </div>
                </div>
            </div>
            
            <div class="test-section">
                <div class="test-section-header">üéÆ Tests de L√≥gica de Juego</div>
                <div class="test-section-content" id="gameLogicTests">
                    <!-- Los tests se generar√°n din√°micamente -->
                </div>
            </div>
            
            <div class="test-section">
                <div class="test-section-header">üåê Tests de Red</div>
                <div class="test-section-content" id="networkTests">
                    <!-- Los tests se generar√°n din√°micamente -->
                </div>
            </div>
            
        </div>
    </div>

    <script>
        // Test Suite para Damas Funer
        class DamasTestSuite {
            constructor() {
                this.results = {
                    gameLogic: [],
                    network: [],
                    ui: []
                };
                this.totalTests = 0;
                this.passedTests = 0;
                this.failedTests = 0;
                
                this.initializeEventListeners();
            }
            
            initializeEventListeners() {
                document.getElementById('runAllTests').addEventListener('click', () => this.runAllTests());
                document.getElementById('runGameLogicTests').addEventListener('click', () => this.runGameLogicTests());
                document.getElementById('runNetworkTests').addEventListener('click', () => this.runNetworkTests());
                document.getElementById('downloadResults').addEventListener('click', () => this.downloadResults());
                document.getElementById('clearResults').addEventListener('click', () => this.clearResults());
            }
            
            async runAllTests() {
                this.clearResults();
                await this.runGameLogicTests();
                await this.runNetworkTests();
                this.updateSummary();
            }
            
            async runGameLogicTests() {
                const tests = [
                    {
                        name: "Inicializaci√≥n del tablero",
                        test: () => this.testBoardInitialization()
                    },
                    {
                        name: "Movimientos v√°lidos de peones",
                        test: () => this.testValidPawnMoves()
                    },
                    {
                        name: "Movimientos inv√°lidos de peones",
                        test: () => this.testInvalidPawnMoves()
                    },
                    {
                        name: "Capturas simples",
                        test: () => this.testSimpleCaptures()
                    },
                    {
                        name: "Capturas m√∫ltiples",
                        test: () => this.testMultipleCaptures()
                    },
                    {
                        name: "Promoci√≥n a reina",
                        test: () => this.testQueenPromotion()
                    },
                    {
                        name: "Movimientos de reina",
                        test: () => this.testQueenMoves()
                    },
                    {
                        name: "Detecci√≥n de victoria",
                        test: () => this.testWinDetection()
                    },
                    {
                        name: "Conteo de capturas",
                        test: () => this.testCaptureCounting()
                    },
                    {
                        name: "Validaci√≥n de turnos",
                        test: () => this.testTurnValidation()
                    }
                ];
                
                await this.runTestCategory('gameLogic', tests);
            }
            
            async runNetworkTests() {
                const tests = [
                    {
                        name: "Creaci√≥n de partida",
                        test: () => this.testGameCreation()
                    },
                    {
                        name: "Uni√≥n a partida existente",
                        test: () => this.testJoinGame()
                    },
                    {
                        name: "Env√≠o de movimientos",
                        test: () => this.testSendMove()
                    },
                    {
                        name: "Obtenci√≥n de estado del juego",
                        test: () => this.testGetGameState()
                    },
                    {
                        name: "Manejo de errores de red",
                        test: () => this.testNetworkErrorHandling()
                    }
                ];
                
                await this.runTestCategory('network', tests);
            }
            
            
            async runTestCategory(category, tests) {
                const container = document.getElementById(category + 'Tests');
                container.innerHTML = '';
                
                for (const test of tests) {
                    const testElement = this.createTestElement(test.name);
                    container.appendChild(testElement);
                    
                    try {
                        testElement.classList.add('running');
                        const result = await test.test();
                        this.handleTestResult(category, test.name, result, testElement);
                    } catch (error) {
                        this.handleTestResult(category, test.name, {
                            success: false,
                            message: error.message,
                            details: error.stack
                        }, testElement);
                    }
                }
            }
            
            createTestElement(testName) {
                const div = document.createElement('div');
                div.className = 'test-item';
                div.innerHTML = `
                    <div class="test-name">${testName}</div>
                    <div class="test-status">‚è≥ Ejecutando...</div>
                    <div class="test-details"></div>
                `;
                return div;
            }
            
            handleTestResult(category, testName, result, element) {
                this.totalTests++;
                
                if (result.success) {
                    this.passedTests++;
                    element.classList.remove('running');
                    element.classList.add('pass');
                    element.querySelector('.test-status').textContent = '‚úÖ Pas√≥';
                } else {
                    this.failedTests++;
                    element.classList.remove('running');
                    element.classList.add('fail');
                    element.querySelector('.test-status').textContent = '‚ùå Fall√≥';
                }
                
                element.querySelector('.test-details').textContent = result.message || '';
                if (result.details) {
                    element.querySelector('.test-details').textContent += '\n\nDetalles:\n' + result.details;
                }
                
                this.results[category].push({
                    name: testName,
                    success: result.success,
                    message: result.message,
                    details: result.details
                });
            }
            
            updateSummary() {
                const summary = document.getElementById('testSummary');
                const passRate = this.totalTests > 0 ? (this.passedTests / this.totalTests * 100).toFixed(1) : 0;
                
                summary.innerHTML = `
                    <div>Total: ${this.totalTests} | Pasaron: ${this.passedTests} | Fallaron: ${this.failedTests}</div>
                    <div>Tasa de √©xito: ${passRate}%</div>
                `;
                
                if (this.failedTests === 0) {
                    summary.classList.add('pass');
                    summary.classList.remove('fail');
                } else {
                    summary.classList.add('fail');
                    summary.classList.remove('pass');
                }
            }
            
            clearResults() {
                this.results = { gameLogic: [], network: [] };
                this.totalTests = 0;
                this.passedTests = 0;
                this.failedTests = 0;
                
                document.getElementById('gameLogicTests').innerHTML = '';
                document.getElementById('networkTests').innerHTML = '';
                
                const summary = document.getElementById('testSummary');
                summary.textContent = 'Presiona "Ejecutar Todos los Tests" para comenzar';
                summary.className = 'summary';
            }
            
            downloadResults() {
                console.log('Download button clicked');
                console.log('totalTests:', this.totalTests);
                console.log('results.gameLogic.length:', this.results.gameLogic.length);
                console.log('results.network.length:', this.results.network.length);
                console.log('results:', this.results);
                
                if (this.totalTests === 0 || (this.results.gameLogic.length === 0 && this.results.network.length === 0)) {
                    const proceed = confirm('No hay resultados de tests para descargar. ¬øDeseas descargar un reporte vac√≠o?');
                    if (!proceed) {
                        return;
                    }
                }
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `test_suite_results_${timestamp}.txt`;
                
                let report = `=== RESULTADOS DE TEST SUITE - DAMAS FUNER ===\n`;
                report += `Fecha: ${new Date().toLocaleString()}\n`;
                report += `Total de tests: ${this.totalTests}\n`;
                report += `Tests pasados: ${this.passedTests}\n`;
                report += `Tests fallidos: ${this.failedTests}\n`;
                report += `Tasa de √©xito: ${this.totalTests > 0 ? (this.passedTests / this.totalTests * 100).toFixed(1) : 0}%\n\n`;
                
                // Tests de L√≥gica de Juego
                if (this.results.gameLogic.length > 0) {
                    report += `=== TESTS DE L√ìGICA DE JUEGO ===\n\n`;
                    this.results.gameLogic.forEach((result, index) => {
                        report += `${index + 1}. ${result.name}\n`;
                        report += `   Estado: ${result.success ? 'PAS√ì' : 'FALL√ì'}\n`;
                        report += `   Mensaje: ${result.message || 'Sin mensaje'}\n`;
                        if (result.details) {
                            report += `   Detalles: ${result.details}\n`;
                        }
                        report += `\n`;
                    });
                }
                
                // Tests de Red
                if (this.results.network.length > 0) {
                    report += `=== TESTS DE RED ===\n\n`;
                    this.results.network.forEach((result, index) => {
                        report += `${index + 1}. ${result.name}\n`;
                        report += `   Estado: ${result.success ? 'PAS√ì' : 'FALL√ì'}\n`;
                        report += `   Mensaje: ${result.message || 'Sin mensaje'}\n`;
                        if (result.details) {
                            report += `   Detalles: ${result.details}\n`;
                        }
                        report += `\n`;
                    });
                }
                
                // Tests de Interfaz
                if (this.results.ui.length > 0) {
                    report += `=== TESTS DE INTERFAZ ===\n\n`;
                    this.results.ui.forEach((result, index) => {
                        report += `${index + 1}. ${result.name}\n`;
                        report += `   Estado: ${result.success ? 'PAS√ì' : 'FALL√ì'}\n`;
                        report += `   Mensaje: ${result.message || 'Sin mensaje'}\n`;
                        if (result.details) {
                            report += `   Detalles: ${result.details}\n`;
                        }
                        report += `\n`;
                    });
                }
                
                report += `=== INFORMACI√ìN DEL SISTEMA ===\n`;
                report += `User Agent: ${navigator.userAgent}\n`;
                report += `URL: ${window.location.href}\n`;
                report += `Timestamp: ${new Date().toISOString()}\n`;
                
                // Crear y descargar el archivo
                try {
                    const blob = new Blob([report], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                    // Mostrar mensaje de √©xito
                    console.log('Archivo descargado exitosamente:', filename);
                    
                    // Mostrar notificaci√≥n temporal
                    const notification = document.createElement('div');
                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #28a745;
                        color: white;
                        padding: 15px 20px;
                        border-radius: 5px;
                        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                        z-index: 1000;
                        font-weight: bold;
                    `;
                    notification.textContent = `‚úÖ Archivo descargado: ${filename}`;
                    document.body.appendChild(notification);
                    
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 3000);
                } catch (error) {
                    console.error('Error al descargar archivo:', error);
                    alert('Error al descargar el archivo. Int√©ntalo de nuevo.');
                }
            }
            
            // ===== TESTS DE L√ìGICA DE JUEGO =====
            
            testBoardInitialization() {
                // Simular la inicializaci√≥n del tablero
                const board = this.createInitialBoard();
                
                // Verificar que el tablero tiene 8x8
                if (board.length !== 8 || board[0].length !== 8) {
                    return { success: false, message: 'El tablero no tiene dimensiones 8x8' };
                }
                
                // Verificar que hay 12 piezas de cada jugador
                let player1Pieces = 0;
                let player2Pieces = 0;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (board[row][col]) {
                            if (board[row][col].player === 1) player1Pieces++;
                            if (board[row][col].player === 2) player2Pieces++;
                        }
                    }
                }
                
                if (player1Pieces !== 12 || player2Pieces !== 12) {
                    return { 
                        success: false, 
                        message: `Piezas incorrectas: Jugador 1: ${player1Pieces}, Jugador 2: ${player2Pieces}` 
                    };
                }
                
                return { success: true, message: 'Tablero inicializado correctamente' };
            }
            
            testValidPawnMoves() {
                const board = this.createPawnMoveTestBoard();
                
                // Test movimiento v√°lido de pe√≥n blanco (jugador 1) - hacia arriba
                const validMove = this.isValidMove(board, 5, 0, 4, 1, 1);
                if (!validMove) {
                    return { success: false, message: 'Movimiento v√°lido de pe√≥n blanco rechazado' };
                }
                
                // Test movimiento v√°lido de pe√≥n negro (jugador 2) - hacia abajo
                const validMove2 = this.isValidMove(board, 2, 1, 3, 0, 2);
                if (!validMove2) {
                    return { success: false, message: 'Movimiento v√°lido de pe√≥n negro rechazado' };
                }
                
                // Test movimiento v√°lido de pe√≥n blanco en diagonal
                const validMove3 = this.isValidMove(board, 5, 2, 4, 3, 1);
                if (!validMove3) {
                    return { success: false, message: 'Movimiento diagonal v√°lido de pe√≥n blanco rechazado' };
                }
                
                return { success: true, message: 'Movimientos v√°lidos de peones funcionan correctamente' };
            }
            
            testInvalidPawnMoves() {
                const board = this.createInitialBoard();
                
                // Test movimiento inv√°lido (hacia atr√°s)
                const invalidMove = this.isValidMove(board, 5, 0, 6, 1, 1);
                if (invalidMove) {
                    return { success: false, message: 'Movimiento inv√°lido hacia atr√°s aceptado' };
                }
                
                // Test movimiento inv√°lido (a casilla ocupada)
                const invalidMove2 = this.isValidMove(board, 5, 0, 4, 1, 1);
                if (invalidMove2) {
                    return { success: false, message: 'Movimiento a casilla ocupada aceptado' };
                }
                
                return { success: true, message: 'Movimientos inv√°lidos correctamente rechazados' };
            }
            
            testSimpleCaptures() {
                // Crear un tablero de prueba con piezas en posiciones para captura
                const board = this.createCaptureTestBoard();
                
                // Simular una captura simple: pieza blanca en (5,0) captura pieza negra en (4,1)
                const captureResult = this.simulateCapture(board, 5, 0, 3, 2, 1);
                
                if (!captureResult.success) {
                    return { success: false, message: captureResult.message };
                }
                
                const captureBoard = captureResult.board;
                
                // Verificar que la pieza capturada fue eliminada
                if (captureBoard[4][1]) {
                    return { success: false, message: 'Pieza capturada no fue eliminada' };
                }
                
                // Verificar que la pieza captora est√° en la posici√≥n correcta
                if (!captureBoard[3][2] || captureBoard[3][2].player !== 1) {
                    return { success: false, message: 'Pieza captora no est√° en la posici√≥n correcta' };
                }
                
                return { success: true, message: 'Captura simple funciona correctamente' };
            }
            
            testMultipleCaptures() {
                // Crear un tablero de prueba para capturas m√∫ltiples
                const board = this.createMultipleCaptureTestBoard();
                
                // Simular capturas m√∫ltiples
                const multiCaptureResult = this.simulateMultipleCaptures(board, 1);
                
                if (!multiCaptureResult.success) {
                    return { success: false, message: multiCaptureResult.message };
                }
                
                const multiCaptureBoard = multiCaptureResult.board;
                
                // Verificar que se realizaron m√∫ltiples capturas
                let capturedPieces = 0;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (board[row][col] && !multiCaptureBoard[row][col]) {
                            capturedPieces++;
                        }
                    }
                }
                
                if (capturedPieces < 2) {
                    return { success: false, message: 'Capturas m√∫ltiples no funcionan correctamente' };
                }
                
                return { success: true, message: 'Capturas m√∫ltiples funcionan correctamente' };
            }
            
            testQueenPromotion() {
                const board = this.createInitialBoard();
                
                // Simular promoci√≥n a reina
                const queenBoard = this.simulateQueenPromotion(board, 1);
                
                // Verificar que hay una reina en la fila 0
                let hasQueen = false;
                for (let col = 0; col < 8; col++) {
                    if (queenBoard[0][col] && queenBoard[0][col].isQueen && queenBoard[0][col].player === 1) {
                        hasQueen = true;
                        break;
                    }
                }
                
                if (!hasQueen) {
                    return { success: false, message: 'Promoci√≥n a reina no funcion√≥' };
                }
                
                return { success: true, message: 'Promoci√≥n a reina funciona correctamente' };
            }
            
            testQueenMoves() {
                const board = this.createQueenTestBoard();
                
                // Test movimiento diagonal de reina
                const queenMove = this.isValidQueenMove(board, 3, 3, 5, 5, 1);
                if (!queenMove) {
                    return { success: false, message: 'Movimiento diagonal de reina rechazado' };
                }
                
                return { success: true, message: 'Movimientos de reina funcionan correctamente' };
            }
            
            testWinDetection() {
                const board = this.createInitialBoard();
                
                // Simular que el jugador 2 no tiene piezas
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (board[row][col] && board[row][col].player === 2) {
                            board[row][col] = null;
                        }
                    }
                }
                
                const winner = this.checkWinner(board);
                if (winner !== 1) {
                    return { success: false, message: 'Detecci√≥n de victoria no funciona' };
                }
                
                return { success: true, message: 'Detecci√≥n de victoria funciona correctamente' };
            }
            
            testCaptureCounting() {
                // Crear un tablero de prueba con piezas en posiciones para captura
                const board = this.createCaptureTestBoard();
                
                // Simular capturas
                const captureResult = this.simulateCapture(board, 5, 0, 3, 2, 1);
                
                if (!captureResult.success) {
                    return { success: false, message: captureResult.message };
                }
                
                const captureBoard = captureResult.board;
                const captures = this.countCaptures(board, captureBoard, 1);
                
                if (captures !== 1) {
                    return { success: false, message: `Conteo de capturas incorrecto: ${captures}` };
                }
                
                return { success: true, message: 'Conteo de capturas funciona correctamente' };
            }
            
            testTurnValidation() {
                const game = { currentPlayer: 1 };
                
                // Test que solo el jugador actual puede mover
                const canMove = this.canPlayerMove(game, 1);
                const cannotMove = this.canPlayerMove(game, 2);
                
                if (!canMove || cannotMove) {
                    return { success: false, message: 'Validaci√≥n de turnos no funciona' };
                }
                
                return { success: true, message: 'Validaci√≥n de turnos funciona correctamente' };
            }
            
            // ===== TESTS DE RED =====
            
            async testGameCreation() {
                try {
                    const response = await fetch('../api/create_game.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ player_name: 'Test Player' })
                    });
                    
                    // Verificar si la respuesta es HTML (error 404 o similar)
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        const text = await response.text();
                        return { 
                            success: false, 
                            message: `Respuesta no es JSON. Status: ${response.status}, Content-Type: ${contentType}`,
                            details: text.substring(0, 200) + '...'
                        };
                    }
                    
                    const data = await response.json();
                    
                    if (!data.success) {
                        return { success: false, message: 'Error al crear partida: ' + data.message };
                    }
                    
                    return { success: true, message: 'Creaci√≥n de partida funciona correctamente' };
                } catch (error) {
                    return { success: false, message: 'Error de red: ' + error.message };
                }
            }
            
            async testJoinGame() {
                try {
                    // Primero crear una partida
                    const createResponse = await fetch('../api/create_game.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ player_name: 'Test Player 1' })
                    });
                    
                    // Verificar si la respuesta es HTML
                    const createContentType = createResponse.headers.get('content-type');
                    if (!createContentType || !createContentType.includes('application/json')) {
                        const text = await createResponse.text();
                        return { 
                            success: false, 
                            message: `Error en creaci√≥n de partida. Status: ${createResponse.status}`,
                            details: text.substring(0, 200) + '...'
                        };
                    }
                    
                    const createData = await createResponse.json();
                    if (!createData.success) {
                        return { success: false, message: 'No se pudo crear partida para test: ' + createData.message };
                    }
                    
                    // Luego unirse a la partida
                    const joinResponse = await fetch('../api/join_game.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            game_code: createData.game_code,
                            player_name: 'Test Player 2'
                        })
                    });
                    
                    // Verificar si la respuesta es HTML
                    const joinContentType = joinResponse.headers.get('content-type');
                    if (!joinContentType || !joinContentType.includes('application/json')) {
                        const text = await joinResponse.text();
                        return { 
                            success: false, 
                            message: `Error en uni√≥n a partida. Status: ${joinResponse.status}`,
                            details: text.substring(0, 200) + '...'
                        };
                    }
                    
                    const joinData = await joinResponse.json();
                    
                    if (!joinData.success) {
                        return { success: false, message: 'Error al unirse a partida: ' + joinData.message };
                    }
                    
                    return { success: true, message: 'Uni√≥n a partida funciona correctamente' };
                } catch (error) {
                    return { success: false, message: 'Error de red: ' + error.message };
                }
            }
            
            async testSendMove() {
                try {
                    // Crear una partida de prueba
                    const createResponse = await fetch('../api/create_game.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ player_name: 'Test Player' })
                    });
                    
                    const createData = await createResponse.json();
                    if (!createData.success) {
                        return { success: false, message: 'No se pudo crear partida para test' };
                    }
                    
                    // Crear un board_state de prueba simple (no depender del servidor)
                    const testBoard = Array(8).fill(null).map(() => Array(8).fill(null));
                    testBoard[5][0] = { player: 1, isQueen: false };
                    
                    // Simular un movimiento
                    const moveResponse = await fetch('../api/make_move.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            game_id: createData.game_id,
                            player_id: createData.player_id,
                            from: { row: 5, col: 0 },
                            to: { row: 4, col: 1 },
                            captured_pieces: [],
                            board_state: testBoard
                        })
                    });
                    
                    const moveData = await moveResponse.json();
                    
                    if (!moveData.success) {
                        return { success: false, message: 'Error al enviar movimiento: ' + moveData.message };
                    }
                    
                    return { success: true, message: 'Env√≠o de movimientos funciona correctamente' };
                } catch (error) {
                    return { success: false, message: 'Error de red: ' + error.message };
                }
            }
            
            async testGetGameState() {
                try {
                    // Crear una partida de prueba
                    const createResponse = await fetch('../api/create_game.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ player_name: 'Test Player' })
                    });
                    
                    const createData = await createResponse.json();
                    if (!createData.success) {
                        return { success: false, message: 'No se pudo crear partida para test' };
                    }
                    
                    // Obtener estado del juego
                    const stateResponse = await fetch(`../api/get_game_state.php?game_id=${createData.game_id}&player_id=${createData.player_id}`);
                    const stateData = await stateResponse.json();
                    
                    if (!stateData.success) {
                        return { success: false, message: 'Error al obtener estado: ' + stateData.message };
                    }
                    
                    return { success: true, message: 'Obtenci√≥n de estado funciona correctamente' };
                } catch (error) {
                    return { success: false, message: 'Error de red: ' + error.message };
                }
            }
            
            async testNetworkErrorHandling() {
                try {
                    // Intentar acceder a un endpoint inexistente
                    const response = await fetch('../api/nonexistent_endpoint.php');
                    
                    // Si el endpoint devuelve 404, es el comportamiento esperado
                    if (response.status === 404) {
                        return { success: true, message: 'Manejo de errores de red funciona correctamente (404 detectado)' };
                    }
                    
                    // Si devuelve 200 pero con HTML, tambi√©n es v√°lido
                    const contentType = response.headers.get('content-type');
                    if (response.ok && contentType && contentType.includes('text/html')) {
                        return { success: true, message: 'Manejo de errores de red funciona correctamente (HTML devuelto)' };
                    }
                    
                    // Si devuelve 200 con JSON, es inesperado
                    if (response.ok) {
                        return { success: false, message: 'Endpoint inexistente devolvi√≥ √©xito inesperadamente' };
                    }
                    
                    return { success: true, message: 'Manejo de errores de red funciona correctamente' };
                } catch (error) {
                    return { success: true, message: 'Manejo de errores de red funciona correctamente (excepci√≥n capturada)' };
                }
            }
            
            
            
            // ===== FUNCIONES AUXILIARES =====
            
            createInitialBoard() {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // Player 2 (black) pieces
                for (let row = 0; row < 3; row++) {
                    for (let col = (row % 2); col < 8; col += 2) {
                        board[row][col] = { player: 2, isQueen: false };
                    }
                }
                
                // Player 1 (white) pieces
                for (let row = 5; row < 8; row++) {
                    for (let col = (row % 2); col < 8; col += 2) {
                        board[row][col] = { player: 1, isQueen: false };
                    }
                }
                
                return board;
            }
            
            createCaptureTestBoard() {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // Configurar piezas para captura: pieza blanca en (5,0), pieza negra en (4,1)
                board[5][0] = { player: 1, isQueen: false }; // Pieza blanca
                board[4][1] = { player: 2, isQueen: false }; // Pieza negra a capturar
                
                return board;
            }
            
            createMultipleCaptureTestBoard() {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // Configurar piezas para capturas m√∫ltiples en secuencia
                board[5][0] = { player: 1, isQueen: false }; // Pieza blanca
                board[4][1] = { player: 2, isQueen: false }; // Primera pieza negra a capturar
                board[2][3] = { player: 2, isQueen: false }; // Segunda pieza negra a capturar
                
                return board;
            }
            
            createQueenTestBoard() {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // Crear una reina para testing en posici√≥n (3,3)
                board[3][3] = { player: 1, isQueen: true };
                
                return board;
            }
            
            createPawnMoveTestBoard() {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // Configurar piezas para testing de movimientos
                board[5][0] = { player: 1, isQueen: false }; // Pieza blanca
                board[5][2] = { player: 1, isQueen: false }; // Pieza blanca
                board[2][1] = { player: 2, isQueen: false }; // Pieza negra
                
                return board;
            }
            
            isValidMove(board, fromRow, fromCol, toRow, toCol, player) {
                // Validaci√≥n b√°sica de movimiento
                if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) return false;
                if (board[toRow][toCol] !== null) return false;
                if (!board[fromRow][fromCol] || board[fromRow][fromCol].player !== player) return false;
                
                // Validaci√≥n de movimiento diagonal
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                if (rowDiff !== colDiff) return false;
                
                // Validaci√≥n de direcci√≥n para peones
                if (!board[fromRow][fromCol].isQueen) {
                    if (player === 1 && toRow >= fromRow) return false; // Blancos hacia arriba
                    if (player === 2 && toRow <= fromRow) return false; // Negros hacia abajo
                }
                
                return true;
            }
            
            simulateCapture(board, fromRow, fromCol, toRow, toCol, player) {
                const newBoard = JSON.parse(JSON.stringify(board));
                
                // Verificar que hay una pieza enemiga en el medio
                const middleRow = (fromRow + toRow) / 2;
                const middleCol = (fromCol + toCol) / 2;
                const enemyPlayer = player === 1 ? 2 : 1;
                
                if (!newBoard[middleRow][middleCol] || newBoard[middleRow][middleCol].player !== enemyPlayer) {
                    return { success: false, message: 'No hay pieza enemiga para capturar' };
                }
                
                // Realizar la captura
                newBoard[toRow][toCol] = newBoard[fromRow][fromCol];
                newBoard[fromRow][fromCol] = null;
                newBoard[middleRow][middleCol] = null;
                
                return { success: true, board: newBoard };
            }
            
            simulateMultipleCaptures(board, player) {
                // Simular capturas m√∫ltiples
                let newBoard = JSON.parse(JSON.stringify(board));
                let capturedPieces = 0;
                
                // Simular capturas en secuencia: (5,0) -> (3,2) capturando (4,1)
                const captures = [
                    { from: [5, 0], to: [3, 2], capture: [4, 1] },
                    { from: [3, 2], to: [1, 4], capture: [2, 3] }
                ];
                
                for (const capture of captures) {
                    const [fromRow, fromCol] = capture.from;
                    const [toRow, toCol] = capture.to;
                    const [captureRow, captureCol] = capture.capture;
                    
                    // Verificar que hay una pieza enemiga en la posici√≥n de captura
                    const enemyPlayer = player === 1 ? 2 : 1;
                    if (newBoard[captureRow][captureCol] && newBoard[captureRow][captureCol].player === enemyPlayer) {
                        const captureResult = this.simulateCapture(newBoard, fromRow, fromCol, toRow, toCol, player);
                        if (captureResult.success) {
                            newBoard = captureResult.board;
                            capturedPieces++;
                        }
                    }
                }
                
                if (capturedPieces < 2) {
                    return { success: false, message: 'No se pudieron realizar capturas m√∫ltiples' };
                }
                
                return { success: true, board: newBoard };
            }
            
            simulateQueenPromotion(board, player) {
                const newBoard = JSON.parse(JSON.stringify(board));
                
                // Simular que una pieza llega al final del tablero
                newBoard[0][1] = { player: player, isQueen: true };
                
                return newBoard;
            }
            
            isValidQueenMove(board, fromRow, fromCol, toRow, toCol, player) {
                if (!this.isValidMove(board, fromRow, fromCol, toRow, toCol, player)) return false;
                
                // Verificar que es movimiento diagonal
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                
                return rowDiff === colDiff;
            }
            
            checkWinner(board) {
                let player1Pieces = 0;
                let player2Pieces = 0;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (board[row][col]) {
                            if (board[row][col].player === 1) player1Pieces++;
                            if (board[row][col].player === 2) player2Pieces++;
                        }
                    }
                }
                
                if (player2Pieces === 0) return 1;
                if (player1Pieces === 0) return 2;
                return null;
            }
            
            countCaptures(oldBoard, newBoard, player) {
                let captures = 0;
                const enemyPlayer = player === 1 ? 2 : 1;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (oldBoard[row][col] && oldBoard[row][col].player === enemyPlayer && !newBoard[row][col]) {
                            captures++;
                        }
                    }
                }
                
                return captures;
            }
            
            canPlayerMove(game, player) {
                return game.currentPlayer === player;
            }
            
        }
        
        // Inicializar el test suite cuando se carga la p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            window.testSuite = new DamasTestSuite();
        });
    </script>
</body>
</html>
